#!/usr/bin/python
# @file mock_templates.py
# @author mconway@Espial.com
# @description Templates used to create mock header and source files
# Copyright (C) Espial Limited 2016 Company Confidential - All Rights Reserved


# ##############################################################################
# File banner template

mocked_file_banner_template = \
"""/**
 * @file <filename>
 *
 * @brief Auto generated mock implementation for the header file:
 *        <mocked_header_name>
 *
 * THIS FILE WAS AUTOGENERATED ON <generation_date> BY MCMOCK DO NOT EDIT
 */
"""


# ##############################################################################
# Mocked header template

mock_header_include_guard_template = \
"""<header_file_banner>

#ifndef INCLUDE_MOCK_<mock_name_upper>_H
#define INCLUDE_MOCK_<mock_name_upper>_H

#ifdef __cplusplus
extern "C" {
#endif

<source_code>

#ifdef __cplusplus
}
#endif

#endif /* INCLUDE_MOCK_<mock_name_upper>_H */
"""


# ##############################################################################
# Templates for generating included headers in the mock source:

template_default_includes = \
"""
#include "mock_<mocked_header_name>.h"
#include "<mocked_header>"

#include "mcmock.h"
#include <check.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdarg.h>
"""

template_included_application_header = \
"""
#include \"<include_name>\""""


template_included_system_header = \
"""
#include <<include_name>>"""


# ##############################################################################
# Templates for generating API string names for each mocked API:

template_mocked_apis_comment = \
"""
/* String representations for each mocked API */
"""

template_mocked_api_string = \
"""static const char * api_name_<api_name> = \"<api_name>\";
"""

# ##############################################################################
# Templates for creating a new typedef to handle callback parameters

template_callback_typedef_name = "mock_<function_name>_<callback_name>"
template_create_callback_typedef = \
"""typedef void (*<typedef_name>)(<callback_type> <callback_name>);
"""

# ##############################################################################
# Templates for creating a new typedef to catch input parameters

template_catch_parameter_api_name = "mock_<function_name>_catch_parameter_<param_name>"
template_catch_parameter_typedef_name = "<api_name>_t"
template_create_catch_parameter_typedef = \
"""typedef void (*<typedef_name>)(<param_data_type> <param_name>);
"""

# ##############################################################################
# Templates for generating the typedef test conditions structure for each mocked
# API:

template_mock_conditions_comment = \
"""
/* Structure to store expected test conditions for the mocked API <mocked_api>() */"""

template_mock_conditions_structure = \
"""
typedef struct
{
    const char * api_name;
<conditions>} <api_name>_t;
"""

template_mock_conditions_function_pointer_arg = \
"""    <function_pointer>;
"""

template_mock_conditions_standard_arg = \
"""    <type> <name>;
"""

template_mock_conditions_ignore_arg = \
"""    bool ignore_<name>;
"""

template_mock_conditions_verify_pointer_arg = \
"""    bool verify_pointer_<name>;
    size_t verify_pointer_<name>_size;
"""

template_mock_conditions_catch_parameter_arg = \
"""    <type> catch_<name>;
"""

template_mock_conditions_return_value = \
"""    <type> retval;
"""

template_mock_conditions_va_list = \
"""    va_list <name>;
"""


# ##############################################################################
# Template to add a comment banner before all the mocked API implementations

template_banner_mocked_apis = \
"""
/*******************************************************************************
* Mocked APIs
*/
"""


# ##############################################################################
# Templates to generate the implementation for a mocked API

template_mocked_api_skeleton = \
"""
<mocked_api_return_type> <mocked_api_name>(<mocked_api_params_list>)
{
    <mocked_api_name>_t *conditions = mcmock_get_next_expectation();

    mcmock_assert_msg(
        conditions == NULL,
        "Code under test called API <mocked_api_name>(), but no expectations have been set" );

    mcmock_assert_msg(
        strcmp( conditions->api_name, api_name_<mocked_api_name> ) != 0,
        "Code under test called API <mocked_api_name>(), but test expected API %s() to be called",
        conditions->api_name );
<verify_params><store_callbacks><return_data>
}
"""

template_mocked_api_verify_parameter = \
"""
    /* Check parameter [<param_name>] matches the expected value */
    if ( !conditions->ignore_<param_name> )
    {
        mcmock_assert_msg(
            conditions-><param_name> != <param_name>,
            "Function <mocked_api_name>() parameter [<param_name>]: expected[%p] actual[%p]",
            conditions-><param_name>,
            <param_name> );
    }
"""

template_mocked_api_verify_input_pointer_parameter = \
"""
    /* Unless the test has explicitly told the mock to check the pointer contents
     * just verify that the parameter [<param_name>] matches the expected value.
     */
    if ( !conditions->ignore_<param_name> )
    {
        /* If the unit test code setup a requirement for the mock to verify the
         * actual data pointed to by the input parameter, then compare the memory
         * passed in by the "code under test" with the expectation data setup by
         * the unit test.
         */
        if ( conditions->verify_pointer_<param_name> )
        {
            bool assert_test = memcmp( <param_name>, conditions-><param_name>, conditions->verify_pointer_<param_name>_size ) != 0;
            if ( assert_test )
            {
                mcmock_assert_msg(
                    true,
                    "Function <mocked_api_name>() parameter [<param_name>]: Memory did not match expected! (TODO : Dump the memory buffers)" );
            }
        }
        /* If the unit test code setup a requirement for the mock to pass it the
         * input parameter, then call the registered callback with the parameter
         * so the unit test code can deal with it however it so wishes.
         */
        else if ( conditions->catch_<param_name> )
        {
            conditions->catch_<param_name>( <param_name> );
        }
        /* The unit test has requested that the mock simply verify the actual
         * pointer and nothing more. (i.e. that the memory address being pointed
         * matches).
         */
        else
        {
            mcmock_assert_msg(
                conditions-><param_name> != <param_name>,
                "Function <mocked_api_name>() parameter [<param_name>]: expected[%p] actual[%p]",
                conditions-><param_name>,
                <param_name> );
        }
    }
"""

template_mocked_api_catch_input_pointer_parameter = \
"""
    if ( !conditions->ignore_<param_name> )
    {

    }
"""

template_mocked_api_handle_callback_parameter = \
"""
    /* Invoke the callback registered by the unittest code, so it can decide how
     * to handle the callback being passed by the code under test.
     */
    if ( conditions->callback != NULL )
    {
        conditions->callback( callback );
    }
"""

template_mocked_api_set_return_data = \
"""
    return conditions->retval;"""

# ##############################################################################
# Template to add a comment banner before all the unit test API implementations


template_banner_for_unittest_apis = \
"""
/*******************************************************************************
* APIs for Unit Tests
*/
"""


# ##############################################################################
# Generate the APIs allowing the unit tests to drive the mock implementation


template_unittest_add_expectation_api = \
"""
void <expectation_api_name>(<expectation_parameters>)
{
    <mocked_api_name>_t *conditions = (<mocked_api_name>_t *)malloc( sizeof( <mocked_api_name>_t ) );
    conditions->api_name = api_name_<mocked_api_name>;
<store_expecatation_conditions>
    mcmock_register_expectation( (void*)conditions, api_name_<mocked_api_name> );
}
"""

template_unittest_add_expectation_store_conditions = \
"""    conditions-><parameter> = <parameter>;
"""

template_unittest_add_expectation_store_verify_in_pointer_conditions = \
"""    conditions->verify_pointer_<parameter> = false;
    conditions->verify_pointer_<parameter>_size = 0;
    conditions->catch_<parameter> = NULL;
"""

template_unittest_add_expectation_store_ignore_conditions = \
"""    conditions->ignore_<parameter> = false;
"""

template_unittest_ignore_arg_api = \
"""
void <api_name>( void )
{
    <mocked_api_name>_t * conditions = ( <mocked_api_name>_t * )mcmock_peek_latest_expectation();
    mcmock_assert_msg(
        strcmp( conditions->api_name, api_name_<mocked_api_name> ) != 0,
        "\\nTest error: Cannot ignore parameter [<parameter_being_ignored>] for API [<mocked_api_name>] because the expectation is for API [%s]",
        conditions->api_name );
    conditions->ignore_<parameter_being_ignored> = true;
}
"""

template_unittest_verify_in_pointer_api = \
"""
void <api_name>( <parameters> )
{
    <mocked_api_name>_t * conditions = ( <mocked_api_name>_t * )mcmock_peek_latest_expectation();
    mcmock_assert_msg(
        strcmp( conditions->api_name, api_name_<mocked_api_name> ) != 0,
        "\\nTest error: Cannot set verify parameter [<parameter_being_verified>] for API [<mocked_api_name>] because the expectation is for API [%s]",
        conditions->api_name );

    conditions->verify_pointer_<parameter_being_verified> = true;
    conditions->verify_pointer_<parameter_being_verified>_size = buffer_size;
}
"""


template_unittest_catch_in_pointer_api = \
"""
void <api_name>( <parameters> )
{
    <mocked_api_name>_t * conditions = ( <mocked_api_name>_t * )mcmock_peek_latest_expectation();
    mcmock_assert_msg(
        strcmp( conditions->api_name, api_name_<mocked_api_name> ) != 0,
        "\\nTest error: Cannot setup callback for input parameter [<parameter_being_caught>] for API [<mocked_api_name>] because the expectation is for API [%s]",
        conditions->api_name );

    conditions->catch_<parameter_being_caught> = callback;
    conditions->catch_<parameter_being_caught> = callback;
}
"""

