/**
 * @file mock_macros.c
 *
 * @brief Auto generated mock implementation for the header file:
 *        macros.h
 *
 * THIS FILE WAS AUTOGENERATED ON 11/11/2020 BY MCMOCK DO NOT EDIT
 */

#include "mock_macros.h"
#include "macros.h"

#include "mcmock.h"
#include <check.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdarg.h>

/* String representations for each mocked API */
static const char * api_name_MIN = "MIN";
static const char * api_name_MAX = "MAX";
static const char * api_name_WARN_IF = "WARN_IF";

/* Structure to store expected test conditions for the mocked API MIN() */
typedef struct
{
    const char * api_name;
    X arg_X_a;
    Y arg_Y_b;
    bool ignore_arg_X_a;
    bool ignore_arg_Y_b;
    #define retval;
} MIN_t;

/* Structure to store expected test conditions for the mocked API MAX() */
typedef struct
{
    const char * api_name;
    X arg_X_c;
    Y arg_Y_d;
    bool ignore_arg_X_c;
    bool ignore_arg_Y_d;
    #define retval;
} MAX_t;

/* Structure to store expected test conditions for the mocked API WARN_IF() */
typedef struct
{
    const char * api_name;
    EXP arg_EXP_e;
    bool ignore_arg_EXP_e;
    #define retval;
} WARN_IF_t;

/*******************************************************************************
* Mocked APIs
*/

#define MIN( X arg_X_a, Y arg_Y_b )
{
    MIN_t *conditions = mcmock_get_next_expectation();

    mcmock_assert_msg(
        conditions == NULL,
        "Code under test called API MIN(), but no expectations have been set" );

    mcmock_assert_msg(
        strcmp( conditions->api_name, api_name_MIN ) != 0,
        "Code under test called API MIN(), but test expected API %s() to be called",
        conditions->api_name );

    /* Check parameter [arg_X_a] matches the expected value */
    if ( !conditions->ignore_arg_X_a )
    {
        mcmock_assert_msg(
            conditions->arg_X_a != arg_X_a,
            "Function MIN() parameter [arg_X_a]: expected[%p] actual[%p]",
            conditions->arg_X_a,
            arg_X_a );
    }

    /* Check parameter [arg_Y_b] matches the expected value */
    if ( !conditions->ignore_arg_Y_b )
    {
        mcmock_assert_msg(
            conditions->arg_Y_b != arg_Y_b,
            "Function MIN() parameter [arg_Y_b]: expected[%p] actual[%p]",
            conditions->arg_Y_b,
            arg_Y_b );
    }

    return conditions->retval;
}

#define MAX( X arg_X_c, Y arg_Y_d )
{
    MAX_t *conditions = mcmock_get_next_expectation();

    mcmock_assert_msg(
        conditions == NULL,
        "Code under test called API MAX(), but no expectations have been set" );

    mcmock_assert_msg(
        strcmp( conditions->api_name, api_name_MAX ) != 0,
        "Code under test called API MAX(), but test expected API %s() to be called",
        conditions->api_name );

    /* Check parameter [arg_X_c] matches the expected value */
    if ( !conditions->ignore_arg_X_c )
    {
        mcmock_assert_msg(
            conditions->arg_X_c != arg_X_c,
            "Function MAX() parameter [arg_X_c]: expected[%p] actual[%p]",
            conditions->arg_X_c,
            arg_X_c );
    }

    /* Check parameter [arg_Y_d] matches the expected value */
    if ( !conditions->ignore_arg_Y_d )
    {
        mcmock_assert_msg(
            conditions->arg_Y_d != arg_Y_d,
            "Function MAX() parameter [arg_Y_d]: expected[%p] actual[%p]",
            conditions->arg_Y_d,
            arg_Y_d );
    }

    return conditions->retval;
}

#define WARN_IF( EXP arg_EXP_e )
{
    WARN_IF_t *conditions = mcmock_get_next_expectation();

    mcmock_assert_msg(
        conditions == NULL,
        "Code under test called API WARN_IF(), but no expectations have been set" );

    mcmock_assert_msg(
        strcmp( conditions->api_name, api_name_WARN_IF ) != 0,
        "Code under test called API WARN_IF(), but test expected API %s() to be called",
        conditions->api_name );

    /* Check parameter [arg_EXP_e] matches the expected value */
    if ( !conditions->ignore_arg_EXP_e )
    {
        mcmock_assert_msg(
            conditions->arg_EXP_e != arg_EXP_e,
            "Function WARN_IF() parameter [arg_EXP_e]: expected[%p] actual[%p]",
            conditions->arg_EXP_e,
            arg_EXP_e );
    }

    return conditions->retval;
}

/*******************************************************************************
* APIs for Unit Tests
*/

void mock_MIN_expect_and_return( X arg_X_a, Y arg_Y_b, #define retval )
{
    MIN_t *conditions = (MIN_t *)malloc( sizeof( MIN_t ) );
    conditions->api_name = api_name_MIN;
    conditions->arg_X_a = arg_X_a;
    conditions->arg_Y_b = arg_Y_b;
    conditions->retval = retval;
    conditions->ignore_arg_X_a = false;
    conditions->ignore_arg_Y_b = false;

    mcmock_register_expectation( (void*)conditions, api_name_MIN );
}

void mock_MIN_ignore_arg_arg_X_a( void )
{
    MIN_t * conditions = ( MIN_t * )mcmock_peek_latest_expectation();
    mcmock_assert_msg(
        strcmp( conditions->api_name, api_name_MIN ) != 0,
        "\nTest error: Cannot ignore parameter [arg_X_a] for API [MIN] because the expectation is for API [%s]",
        conditions->api_name );
    conditions->ignore_arg_X_a = true;
}

void mock_MIN_ignore_arg_arg_Y_b( void )
{
    MIN_t * conditions = ( MIN_t * )mcmock_peek_latest_expectation();
    mcmock_assert_msg(
        strcmp( conditions->api_name, api_name_MIN ) != 0,
        "\nTest error: Cannot ignore parameter [arg_Y_b] for API [MIN] because the expectation is for API [%s]",
        conditions->api_name );
    conditions->ignore_arg_Y_b = true;
}

void mock_MAX_expect_and_return( X arg_X_c, Y arg_Y_d, #define retval )
{
    MAX_t *conditions = (MAX_t *)malloc( sizeof( MAX_t ) );
    conditions->api_name = api_name_MAX;
    conditions->arg_X_c = arg_X_c;
    conditions->arg_Y_d = arg_Y_d;
    conditions->retval = retval;
    conditions->ignore_arg_X_c = false;
    conditions->ignore_arg_Y_d = false;

    mcmock_register_expectation( (void*)conditions, api_name_MAX );
}

void mock_MAX_ignore_arg_arg_X_c( void )
{
    MAX_t * conditions = ( MAX_t * )mcmock_peek_latest_expectation();
    mcmock_assert_msg(
        strcmp( conditions->api_name, api_name_MAX ) != 0,
        "\nTest error: Cannot ignore parameter [arg_X_c] for API [MAX] because the expectation is for API [%s]",
        conditions->api_name );
    conditions->ignore_arg_X_c = true;
}

void mock_MAX_ignore_arg_arg_Y_d( void )
{
    MAX_t * conditions = ( MAX_t * )mcmock_peek_latest_expectation();
    mcmock_assert_msg(
        strcmp( conditions->api_name, api_name_MAX ) != 0,
        "\nTest error: Cannot ignore parameter [arg_Y_d] for API [MAX] because the expectation is for API [%s]",
        conditions->api_name );
    conditions->ignore_arg_Y_d = true;
}

void mock_WARN_IF_expect_and_return( EXP arg_EXP_e, #define retval )
{
    WARN_IF_t *conditions = (WARN_IF_t *)malloc( sizeof( WARN_IF_t ) );
    conditions->api_name = api_name_WARN_IF;
    conditions->arg_EXP_e = arg_EXP_e;
    conditions->retval = retval;
    conditions->ignore_arg_EXP_e = false;

    mcmock_register_expectation( (void*)conditions, api_name_WARN_IF );
}

void mock_WARN_IF_ignore_arg_arg_EXP_e( void )
{
    WARN_IF_t * conditions = ( WARN_IF_t * )mcmock_peek_latest_expectation();
    mcmock_assert_msg(
        strcmp( conditions->api_name, api_name_WARN_IF ) != 0,
        "\nTest error: Cannot ignore parameter [arg_EXP_e] for API [WARN_IF] because the expectation is for API [%s]",
        conditions->api_name );
    conditions->ignore_arg_EXP_e = true;
}
